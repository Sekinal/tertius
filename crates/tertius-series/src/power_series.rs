//! Lazy power series with memoized coefficient computation.
//!
//! A power series is represented as:
//! f(x) = a₀ + a₁x + a₂x² + ... = Σᵢ aᵢxⁱ
//!
//! Coefficients are computed on demand and cached.

use parking_lot::RwLock;
use std::sync::Arc;
use tertius_rings::traits::{Field, Ring};

/// A coefficient in a power series.
pub trait SeriesCoeff: Ring + Clone + Send + Sync + 'static {}

impl<T: Ring + Clone + Send + Sync + 'static> SeriesCoeff for T {}

/// Generator function type for lazy coefficient computation.
pub type CoeffGenerator<R> = Arc<dyn Fn(usize) -> R + Send + Sync>;

/// A lazily-evaluated power series.
///
/// Coefficients are computed on demand and cached for efficiency.
/// The series can be infinite, with coefficients generated by a closure.
#[derive(Clone)]
pub struct PowerSeries<R: SeriesCoeff> {
    /// Cached coefficients (may grow as more are computed).
    coeffs: Arc<RwLock<Vec<R>>>,
    /// Generator function for coefficients.
    generator: CoeffGenerator<R>,
    /// Precision limit (maximum number of terms to compute).
    precision: usize,
    /// Known exact length (if finite).
    exact_len: Option<usize>,
}

impl<R: SeriesCoeff> PowerSeries<R> {
    /// Creates a power series from a generator function.
    ///
    /// The generator takes an index `n` and returns the coefficient `aₙ`.
    pub fn from_generator<F>(generator: F, precision: usize) -> Self
    where
        F: Fn(usize) -> R + Send + Sync + 'static,
    {
        Self {
            coeffs: Arc::new(RwLock::new(Vec::new())),
            generator: Arc::new(generator),
            precision,
            exact_len: None,
        }
    }

    /// Creates a power series from explicit coefficients.
    ///
    /// The resulting series has finite length.
    pub fn from_coeffs(coeffs: Vec<R>) -> Self {
        let len = coeffs.len();
        let coeffs_clone = coeffs.clone();
        Self {
            coeffs: Arc::new(RwLock::new(coeffs)),
            generator: Arc::new(move |n| {
                if n < coeffs_clone.len() {
                    coeffs_clone[n].clone()
                } else {
                    R::zero()
                }
            }),
            precision: len,
            exact_len: Some(len),
        }
    }

    /// Creates the zero series.
    pub fn zero(precision: usize) -> Self {
        Self::from_generator(|_| R::zero(), precision)
    }

    /// Creates the constant series (just a₀ = c).
    pub fn constant(c: R, precision: usize) -> Self {
        Self::from_generator(
            move |n| {
                if n == 0 {
                    c.clone()
                } else {
                    R::zero()
                }
            },
            precision,
        )
    }

    /// Creates the identity series x (a₁ = 1, all others zero).
    pub fn identity(precision: usize) -> Self {
        Self::from_generator(
            move |n| {
                if n == 1 {
                    R::one()
                } else {
                    R::zero()
                }
            },
            precision,
        )
    }

    /// Returns the coefficient at index n, computing if necessary.
    pub fn coeff(&self, n: usize) -> R {
        if n >= self.precision {
            return R::zero();
        }

        // Check if already computed
        {
            let cache = self.coeffs.read();
            if n < cache.len() {
                return cache[n].clone();
            }
        }

        // Compute missing coefficients up to n
        let mut cache = self.coeffs.write();
        while cache.len() <= n {
            let idx = cache.len();
            let val = (self.generator)(idx);
            cache.push(val);
        }
        cache[n].clone()
    }

    /// Returns the current precision (maximum computed terms).
    pub fn precision(&self) -> usize {
        self.precision
    }

    /// Sets a new precision limit.
    pub fn with_precision(mut self, precision: usize) -> Self {
        self.precision = precision;
        self
    }

    /// Returns coefficients up to the given degree.
    pub fn coeffs_to(&self, n: usize) -> Vec<R> {
        let limit = n.min(self.precision);
        (0..=limit).map(|i| self.coeff(i)).collect()
    }

    /// Truncates the series to a polynomial of degree n.
    pub fn truncate(&self, n: usize) -> Vec<R> {
        self.coeffs_to(n)
    }

    /// Returns the order (index of first non-zero coefficient).
    ///
    /// Returns `None` if the series appears to be zero up to precision.
    pub fn order(&self) -> Option<usize> {
        for i in 0..self.precision {
            if !self.coeff(i).is_zero() {
                return Some(i);
            }
        }
        None
    }

    /// Checks if the series is zero (up to precision).
    pub fn is_zero(&self) -> bool {
        self.order().is_none()
    }
}

impl<R: SeriesCoeff> std::fmt::Debug for PowerSeries<R>
where
    R: std::fmt::Debug,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let coeffs = self.coeffs_to(5.min(self.precision.saturating_sub(1)));
        write!(f, "PowerSeries({:?}, ...)", coeffs)
    }
}

/// Helper function to create integer n as a ring element.
fn from_usize<R: Ring + Clone>(n: usize) -> R {
    let mut result = R::zero();
    let one = R::one();
    for _ in 0..n {
        result = result + one.clone();
    }
    result
}

/// Helper function to compute n! as a ring element.
fn factorial<R: Ring + Clone>(n: usize) -> R {
    if n == 0 {
        return R::one();
    }
    let mut result = R::one();
    for i in 1..=n {
        result = result * from_usize::<R>(i);
    }
    result
}

/// Well-known power series generators.
impl<R: Field + Clone + Send + Sync + 'static> PowerSeries<R> {
    /// Creates the exponential series: exp(x) = Σ xⁿ/n!
    pub fn exp(precision: usize) -> Self {
        Self::from_generator(
            move |n| {
                let fact = factorial::<R>(n);
                fact.inv().unwrap_or_else(R::zero)
            },
            precision,
        )
    }

    /// Creates the logarithm series: log(1+x) = x - x²/2 + x³/3 - ...
    pub fn log1p(precision: usize) -> Self {
        Self::from_generator(
            move |n| {
                if n == 0 {
                    R::zero()
                } else {
                    let coeff = R::one().field_div(&from_usize::<R>(n));
                    if n % 2 == 0 {
                        R::zero() - coeff // Negative for even n
                    } else {
                        coeff
                    }
                }
            },
            precision,
        )
    }

    /// Creates the sine series: sin(x) = x - x³/3! + x⁵/5! - ...
    pub fn sin(precision: usize) -> Self {
        Self::from_generator(
            move |n| {
                if n % 2 == 0 {
                    return R::zero(); // Even terms are zero
                }

                let fact = factorial::<R>(n);
                let coeff = fact.inv().unwrap_or_else(R::zero);

                // Alternating signs: + for n≡1(4), - for n≡3(4)
                if (n / 2) % 2 == 0 {
                    coeff
                } else {
                    R::zero() - coeff
                }
            },
            precision,
        )
    }

    /// Creates the cosine series: cos(x) = 1 - x²/2! + x⁴/4! - ...
    pub fn cos(precision: usize) -> Self {
        Self::from_generator(
            move |n| {
                if n % 2 == 1 {
                    return R::zero(); // Odd terms are zero
                }

                let fact = factorial::<R>(n);
                let coeff = fact.inv().unwrap_or_else(R::zero);

                // Alternating signs: + for n≡0(4), - for n≡2(4)
                if (n / 2) % 2 == 0 {
                    coeff
                } else {
                    R::zero() - coeff
                }
            },
            precision,
        )
    }

    /// Creates the geometric series: 1/(1-x) = 1 + x + x² + ...
    pub fn geometric(precision: usize) -> Self {
        Self::from_generator(|_| R::one(), precision)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tertius_rings::rationals::Q;

    fn q(n: i64, d: i64) -> Q {
        Q::new(n, d)
    }

    #[test]
    fn test_from_coeffs() {
        let s = PowerSeries::from_coeffs(vec![q(1, 1), q(2, 1), q(3, 1)]);
        assert_eq!(s.coeff(0), q(1, 1));
        assert_eq!(s.coeff(1), q(2, 1));
        assert_eq!(s.coeff(2), q(3, 1));
        assert_eq!(s.coeff(3), q(0, 1));
    }

    #[test]
    fn test_zero() {
        let s: PowerSeries<Q> = PowerSeries::zero(10);
        assert!(s.is_zero());
        assert_eq!(s.order(), None);
    }

    #[test]
    fn test_constant() {
        let s = PowerSeries::constant(q(5, 1), 10);
        assert_eq!(s.coeff(0), q(5, 1));
        assert_eq!(s.coeff(1), q(0, 1));
        assert_eq!(s.order(), Some(0));
    }

    #[test]
    fn test_identity() {
        let s: PowerSeries<Q> = PowerSeries::identity(10);
        assert_eq!(s.coeff(0), q(0, 1));
        assert_eq!(s.coeff(1), q(1, 1));
        assert_eq!(s.coeff(2), q(0, 1));
        assert_eq!(s.order(), Some(1));
    }

    #[test]
    fn test_exp_series() {
        let exp: PowerSeries<Q> = PowerSeries::exp(10);
        // exp(x) = 1 + x + x²/2 + x³/6 + x⁴/24 + ...
        assert_eq!(exp.coeff(0), q(1, 1));
        assert_eq!(exp.coeff(1), q(1, 1));
        assert_eq!(exp.coeff(2), q(1, 2));
        assert_eq!(exp.coeff(3), q(1, 6));
        assert_eq!(exp.coeff(4), q(1, 24));
    }

    #[test]
    fn test_sin_series() {
        let sin: PowerSeries<Q> = PowerSeries::sin(10);
        // sin(x) = x - x³/6 + x⁵/120 - ...
        assert_eq!(sin.coeff(0), q(0, 1));
        assert_eq!(sin.coeff(1), q(1, 1));
        assert_eq!(sin.coeff(2), q(0, 1));
        assert_eq!(sin.coeff(3), q(-1, 6));
        assert_eq!(sin.coeff(4), q(0, 1));
        assert_eq!(sin.coeff(5), q(1, 120));
    }

    #[test]
    fn test_cos_series() {
        let cos: PowerSeries<Q> = PowerSeries::cos(10);
        // cos(x) = 1 - x²/2 + x⁴/24 - ...
        assert_eq!(cos.coeff(0), q(1, 1));
        assert_eq!(cos.coeff(1), q(0, 1));
        assert_eq!(cos.coeff(2), q(-1, 2));
        assert_eq!(cos.coeff(3), q(0, 1));
        assert_eq!(cos.coeff(4), q(1, 24));
    }

    #[test]
    fn test_geometric() {
        let geo: PowerSeries<Q> = PowerSeries::geometric(10);
        for i in 0..10 {
            assert_eq!(geo.coeff(i), q(1, 1));
        }
    }

    #[test]
    fn test_truncate() {
        let s = PowerSeries::from_coeffs(vec![q(1, 1), q(2, 1), q(3, 1), q(4, 1)]);
        let trunc = s.truncate(2);
        assert_eq!(trunc, vec![q(1, 1), q(2, 1), q(3, 1)]);
    }
}
