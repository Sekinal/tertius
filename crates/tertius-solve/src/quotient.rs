//! Quotient ring structure for polynomial systems.
//!
//! Given an ideal I generated by a Gröbner basis, this module provides
//! operations in the quotient ring K[x₁,...,xₙ]/I.

use num_traits::Zero;
use rustc_hash::FxHashMap;
use std::ops::Neg;
use tertius_groebner::monomial::PackedMonomial;
use tertius_rings::traits::Field;

/// Element of the quotient ring represented as a linear combination
/// of standard monomials.
#[derive(Clone, Debug)]
pub struct QuotientElement<R> {
    /// Coefficients indexed by monomial.
    pub coeffs: FxHashMap<PackedMonomial, R>,
}

impl<R: Field + Clone> QuotientElement<R> {
    /// Creates the zero element.
    pub fn zero() -> Self {
        Self {
            coeffs: FxHashMap::default(),
        }
    }

    /// Creates the identity element (constant 1).
    pub fn one(num_vars: usize) -> Self {
        let mut coeffs = FxHashMap::default();
        coeffs.insert(PackedMonomial::one(num_vars), R::one());
        Self { coeffs }
    }

    /// Creates a monomial element.
    pub fn from_monomial(m: PackedMonomial, c: R) -> Self {
        let mut coeffs = FxHashMap::default();
        if !c.is_zero() {
            coeffs.insert(m, c);
        }
        Self { coeffs }
    }

    /// Returns true if this is the zero element.
    pub fn is_zero(&self) -> bool {
        self.coeffs.is_empty() || self.coeffs.values().all(|c| c.is_zero())
    }

    /// Adds another quotient element.
    pub fn add(&self, other: &Self) -> Self {
        let mut result = self.coeffs.clone();
        for (m, c) in &other.coeffs {
            result
                .entry(m.clone())
                .and_modify(|v| *v = v.clone() + c.clone())
                .or_insert_with(|| c.clone());
        }
        // Remove zeros
        result.retain(|_, c| !c.is_zero());
        Self { coeffs: result }
    }

    /// Subtracts another quotient element.
    pub fn sub(&self, other: &Self) -> Self
    where
        R: Neg<Output = R>,
    {
        let mut result = self.coeffs.clone();
        for (m, c) in &other.coeffs {
            let neg_c = c.clone().neg();
            result
                .entry(m.clone())
                .and_modify(|v| *v = v.clone() + neg_c.clone())
                .or_insert(neg_c);
        }
        // Remove zeros
        result.retain(|_, c| !c.is_zero());
        Self { coeffs: result }
    }

    /// Scales by a coefficient.
    pub fn scale(&self, c: &R) -> Self {
        if c.is_zero() {
            return Self::zero();
        }
        let coeffs = self
            .coeffs
            .iter()
            .map(|(m, v)| (m.clone(), v.clone() * c.clone()))
            .filter(|(_, v)| !v.is_zero())
            .collect();
        Self { coeffs }
    }

    /// Returns the coefficient of a monomial.
    pub fn coeff(&self, m: &PackedMonomial) -> R {
        self.coeffs.get(m).cloned().unwrap_or_else(R::zero)
    }

    /// Returns all monomials with non-zero coefficients.
    pub fn monomials(&self) -> impl Iterator<Item = &PackedMonomial> {
        self.coeffs.keys()
    }

    /// Converts to a vector of (coefficient, monomial) pairs.
    pub fn to_terms(&self) -> Vec<(R, PackedMonomial)> {
        self.coeffs
            .iter()
            .map(|(m, c)| (c.clone(), m.clone()))
            .collect()
    }
}

/// The standard monomials (staircase) of a quotient ring.
///
/// These are the monomials not divisible by any leading monomial
/// of the Gröbner basis.
#[derive(Clone, Debug)]
pub struct Staircase {
    /// Standard monomials in lex order.
    pub monomials: Vec<PackedMonomial>,
    /// Map from monomial to index.
    pub index: FxHashMap<PackedMonomial, usize>,
}

impl Staircase {
    /// Creates a staircase from a list of standard monomials.
    pub fn new(monomials: Vec<PackedMonomial>) -> Self {
        let index = monomials
            .iter()
            .enumerate()
            .map(|(i, m)| (m.clone(), i))
            .collect();
        Self { monomials, index }
    }

    /// Returns the dimension (number of standard monomials).
    pub fn dimension(&self) -> usize {
        self.monomials.len()
    }

    /// Returns the index of a monomial, if it's standard.
    pub fn get_index(&self, m: &PackedMonomial) -> Option<usize> {
        self.index.get(m).copied()
    }

    /// Checks if a monomial is standard.
    pub fn is_standard(&self, m: &PackedMonomial) -> bool {
        self.index.contains_key(m)
    }
}

/// Converts a quotient element to a vector in the standard basis.
pub fn to_vector<R: Field + Clone>(elem: &QuotientElement<R>, staircase: &Staircase) -> Vec<R> {
    let mut vec = vec![R::zero(); staircase.dimension()];
    for (m, c) in &elem.coeffs {
        if let Some(idx) = staircase.get_index(m) {
            vec[idx] = c.clone();
        }
    }
    vec
}

/// Converts a vector to a quotient element.
pub fn from_vector<R: Field + Clone>(vec: &[R], staircase: &Staircase) -> QuotientElement<R> {
    let mut coeffs = FxHashMap::default();
    for (i, c) in vec.iter().enumerate() {
        if !c.is_zero() {
            coeffs.insert(staircase.monomials[i].clone(), c.clone());
        }
    }
    QuotientElement { coeffs }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tertius_rings::finite_field::FiniteField;

    type GF101 = FiniteField<101>;

    fn ff(n: u64) -> GF101 {
        GF101::new(n % 101)
    }

    fn mono(exps: &[u16]) -> PackedMonomial {
        PackedMonomial::new(exps)
    }

    #[test]
    fn test_quotient_element_add() {
        let a = QuotientElement::from_monomial(mono(&[1, 0]), ff(2));
        let b = QuotientElement::from_monomial(mono(&[0, 1]), ff(3));
        let sum = a.add(&b);

        assert_eq!(sum.coeff(&mono(&[1, 0])), ff(2));
        assert_eq!(sum.coeff(&mono(&[0, 1])), ff(3));
    }

    #[test]
    fn test_staircase() {
        let mons = vec![mono(&[0, 0]), mono(&[1, 0]), mono(&[0, 1])];
        let staircase = Staircase::new(mons);

        assert_eq!(staircase.dimension(), 3);
        assert!(staircase.is_standard(&mono(&[1, 0])));
        assert!(!staircase.is_standard(&mono(&[2, 0])));
    }
}
